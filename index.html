<!DOCTYPE HTML>
<!--
	Future Imperfect by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Future Imperfect by HTML5 UP</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="main.css" />
	</head>
	<head>
		<title>Future Imperfect by HTML5 UP</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=no" />
		<link rel="stylesheet" href="main.css" />
		<style>
			.image.fit img {
				border: 2px solid black !important; /* Ensures a 2px black border */
				padding: 0; /* Removes any padding */
				box-sizing: border-box; /* Ensures the border is included within the element's dimensions */
			}
		</style>
	</head>
	<head>
    <title>Future Imperfect by HTML5 UP</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=no" />
    <link rel="stylesheet" href="main.css" />
    <style>
        .image.fit img {
            border: 2px solid black !important; /* Ensures a 2px black border */
            padding: 0; /* Removes any padding */
            box-sizing: border-box; /* Ensures the border is included within the element's dimensions */
        }
    </style>
</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<h1><a href="index.html">Oscar Barajas Portfolio</a></h1>
						<nav class="links">
							<ul>
							
							</ul>
						</nav>
						<nav class="main">
							<ul>
								<li class="search">
									<a class="fa-search" href="#search">Search</a>
									<form id="search" method="get" action="#">
										<input type="text" name="query" placeholder="Search" />
									</form>
								</li>
								<li class="menu">
									<a class="fa-bars" href="#menu">Menu</a>
								</li>
							</ul>
						</nav>
					</header>

				<!-- Menu -->
					<section id="menu">

						<!-- Search -->
							<section>
								<form class="search" method="get" action="#">
									<input type="text" name="query" placeholder="Search" />
								</form>
							</section>

						<!-- Links -->
							<section>
								<ul class="links">
									<li>
										<a href="#">
											<h3>Lorem ipsum</h3>
											<p>Feugiat tempus veroeros dolor</p>
										</a>
									</li>
									<li>
										<a href="#">
											<h3>Dolor sit amet</h3>
											<p>Sed vitae justo condimentum</p>
										</a>
									</li>
									<li>
										<a href="#">
											<h3>Feugiat veroeros</h3>
											<p>Phasellus sed ultricies mi congue</p>
										</a>
									</li>
									<li>
										<a href="#">
											<h3>Etiam sed consequat</h3>
											<p>Porta lectus amet ultricies</p>
										</a>
									</li>
								</ul>
							</section>

						<!-- Actions -->
							<section>
								<ul class="actions stacked">
									<li><a href="#" class="button large fit">Log In</a></li>
								</ul>
							</section>

					</section>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<!-- Post -->
						<article class="post">
							<header>
								<div class="title">
									<h2><a href="#"> VLSI Design and Optimization of a 16X8 SRAM in 14nm CMOS Technology   </a></h2>
									<h2><p href=""> Designed a 16×8 SRAM in 14nm CMOS technology using Synopsys EDA tools, adhering to strict design constraints  </p></h2>
								</div>
							</header>
							<section>
		
								<div class="image featured"><span class="image fit"><div class="outlined-image"><img src="sram5.JPG" alt="" /></div></span></div>
								<h2>Project Overview:</h2> 
								<p style="font-size: 1.5em; font-weight: normal;">
									Designed a 16×8 SRAM in 14nm CMOS technology using Synopsys EDA tools, adhering to strict design constraints including a 4-bit address bus, 8-bit input/output data buses, and operational requirements at 0.8V and 110°C. Ensured a minimum read SNM of 150mV, a bit-line differential of 100mV in read mode, and a maximum standby power of 100µW. Focused on optimizing chip area, access time, and power efficiency.
								</p>
							
								<hr />
								
								<section>
									<h3>Architecture Layout</h3>
									<h4>Fit</h4>
									<div class="box alt">
										<div class="row gtr-uniform">
											<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="sram10.JPG" alt="" /></div></span></div>
											<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="sram3.jpg" alt="" /></div></span></div>
											<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="sram6.jpg" alt="" /></div></span></div>
											<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="sram8.jpg" alt="" /></div></span></div>
											
										</div>
									</div>
								</section>
					
					</article>

							<!-- Post -->
<article class="post">
	<header>
		<div class="title">
			<h2><a> Siemens Field Engineer: Emergency Brake Control Logic Optimization and Fault Analysis </a></h2>
			<h2><p href=""> As Siemens Field Engineer Worked on Enhancing PBEB Signal Timing Logic and Reliability Testing for Siemens LRV44 </p></h2>
			
		</div>
		
			
		
	</header>

	<section>
		
		<div class="image featured"><span class="image fit"><div class="outlined-image"><img src="pbeb1.JPG" alt="" /></div></span></div>
		<h2>Project Overview:</h2> 
		<p style="font-size: 1.5em; font-weight: normal;">
			Collaborated with a cross-functional team to identify and resolve recurring DM_377 faults within Siemens LRV4 control systems. Conducted comprehensive field tests and analyzed fault data to isolate conditions triggering PBEB (Panic Brake Emergency Button) inconsistencies, particularly in Auto mode. Recommended and validated software adjustments, including delay mechanisms, to prevent nuisance faults while ensuring accurate emergency brake function. Coordinated testing schedules and supported live troubleshooting to enhance system reliability, reducing fault incidents by over 50% through optimized PBEB control logic
		</p>
	
	
		<h2>Issue Background and Fault Diagnosis:</h2> 
		<p style="font-size: 1.5em; font-weight: normal;">
			The DM_377 fault is triggered under specific conditions involving the PBEB button, notably when it’s released slowly, causing an inconsistency between contacts that interrupts the T/L (trainline). Faults occur due to a delay in signal consistency, where a slow reset of the PBEB doesn’t align with the system’s 1-second monitoring window, especially in Auto mode. This can be attributed to either the slow release of the PBEB by operators or mechanical issues like stickiness or misalignment in PBEB components.
		</p>


<h2>Proposed Solutions and Testing Strategy:</h2> 

<p style="font-size: 1.5em; font-weight: normal;">
    To reduce “nuisance faults” in the PBEB signal path, a 3-second DELAYOFF was proposed, effectively extending the delay to around 4 seconds. This accounts for variations in operator intent and potential mechanical inconsistencies, ensuring smoother operation. Initial tests confirmed that delayed release or holding of the PBEB button in Auto mode could trigger the fault, prompting a recommendation to incorporate these timing modifications in new software versions.
</p>


	
		
		
		<hr />
		
		<h4>main.c</h4>
		<pre><code>
	
			#include "inc/hw_memmap.h"
			#include "inc/hw_types.h"
			#include "driverlib/sysctl.h"
			#include "driverlib/gpio.h"
			
			// Define ports and pins for sensors and relays
		 
				
			</code></pre>


	

			<section>
				<h3>Image</h3>
				<h4>Fit</h4>
				<div class="box alt">
					<div class="row gtr-uniform">
						<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="pbeb3.JPG" alt="" /></div></span></div>
						<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="pbeb2.jpg" alt="" /></div></span></div>
						<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="pbeb4.jpg" alt="" /></div></span></div>
						<div class="col-6"><span class="image fit"><div class="outlined-image"><img src="pbeb1.jpg" alt="" /></div></span></div>
						
					</div>
				</div>
			</section>

</article>

						
<article class="post">
	<header>
		<div class="title">
			<h2><a href="">Siemens Field Engineer: LRV4 Hardware Design Door Faults: A Software-Driven Solution

			</a></h2>
			<p>Software Change Addresses Siemens MUNI LRV4 Hardware Design Change</p>
		</div>
		
			
		
	</header>

	<section>
		<a class="image featured"><img src="diode5.jpg" /></a>
		<h2>Project Overview:</h2>
		<p style="font-size: 1.5em; font-weight: normal;">
			The Siemens MUNI LRV4 train encountered a recurring "nuisance fault" in its door system due to initial hardware design, triggering non-critical alerts. An added diode intended to fix this caused a new functional fault, impacting train operations. Following extensive troubleshooting, a software-based solution was implemented to resolve both faults, eliminating the need for further hardware changes. This approach was not only cost-effective but also enabled a swift resolution.
		
	
		
		<h2>Project Overview:</h2> 
		<p style="font-size: 1.5em; font-weight: normal;">
			The Siemens MUNI LRV4 door system experienced two types of faults due to the initial hardware setup:

1) Nuisance Fault: A diode was added to resolve non-critical alerts, which had no operational impact.
2)Functional Fault: The diode addition inadvertently created a functional fault, impacting vehicle operation by misinterpreting certain door states.
Faults were attributed to inconsistencies in signal handling, particularly during specific door disable operations, which differed from expected behavior across various modes.
		</p>
	
	
		<h2>Issue Background and Fault Diagnosis:</h2> 
		<p style="font-size: 1.5em; font-weight: normal;">
			The DM_377 fault is triggered under specific conditions involving the PBEB button, notably when it’s released slowly, causing an inconsistency between contacts that interrupts the T/L (trainline). Faults occur due to a delay in signal consistency, where a slow reset of the PBEB doesn’t align with the system’s 1-second monitoring window, especially in Auto mode. This can be attributed to either the slow release of the PBEB by operators or mechanical issues like stickiness or misalignment in PBEB components.
		</p>


<h2>Proposed Solutions and Testing Strategy:</h2> 

<p style="font-size: 1.5em; font-weight: normal;">
	The team identified a software solution to filter out unnecessary alerts, removing the diode and instead implementing signal conditioning logic to differentiate between intentional and erroneous faults.
	Testing validated that the software solution effectively prevented both nuisance and functional faults without modifying hardware. The strategy included isolating the diode’s influence and adjusting signal paths to ensure accurate door state reporting across all operation modes
</p>



	
		
		
		<hr />
		
		


	

	<section>
		<h3>Imagee</h3>
		<h4>Fit</h4>
		<div class="box alt">
			<div class="row gtr-uniform">
				<div class="col-6"><span class="image fit"><img src="diode4.jpg" alt="" /></span></div>
				<div class="col-6"><span class="image fit"><img src="diode3.jpg" alt="" /></span></div>
				<div class="col-6"><span class="image fit"><img src="diode1.jpg" alt="" /></span></div>
				<div class="col-6"><span class="image fit"><img src="diode2.jpg" alt="" /></span></div>
			
			
				 </div>
		</div>
	</section>

</article>
						<!-- Post -->
						<article class="post">
							<header>
								<div class="title">
									<h2><a href="#"> Design Verification: 7-SERIES FPGA UART TIMING ANALYSIS ON ZYNQ SoC   </a></h2>
									<p>HARDWARE used for implimentation PYNQ-Z2  </p>
								
								</div>
							</header>

							<section>
								<a href="single.html" class="image featured"><img src="Timing.png" alt="" /></a>
								<p style="font-size: 1.5em; font-weight: normal;">

									The primary objective of this project is to design and implement a UART  module on the Zynq-7000 SoC platform, part of the Xilinx 7-Series FPGA family. The project focuses on verifying the design through static timing analysis (STA) to ensure that all critical paths meet the required timing constraints. Both simulation and hardware testing are performed to validate functionality, timing closure, and correct operation in real-world conditions.
							</p>
								<hr />
								<h2>SDC Constraints for UART Timing Analysis</h4>
								<pre><code>
									create_clock -period 20.000 [get_ports clk]  # 50 MHz clock (20 ns period)

									# Setup and hold constraints for the UART send signal
									set_input_delay -max 2.000 -clock [get_ports clk] [get_ports send]
									set_input_delay -min 1.000 -clock [get_ports clk] [get_ports send]
									
									# Output delay constraints for the TX output
									set_output_delay -max 2.000 -clock [get_ports clk] [get_ports tx]
									set_output_delay -min 1.000 -clock [get_ports clk] [get_ports tx]
									
									# False paths for reset (not involved in data path)
									set_false_path -from [get_ports rst_n]</code></pre>
						

							

							<section>
								<h2>Verilog Code for UART Transmitter</h4>
									<pre><code>
										
    module uart_tx (
    input wire clk,               // Clock input
    input wire rst_n,             // Active-low reset
    input wire [7:0] data_in,     // 8-bit parallel data
    input wire send,              // Signal to start transmission
    output reg tx,                // Serial data output
    output reg busy               // Transmission in progress indicator
);

    parameter BAUD_RATE = 9600;
    parameter CLK_FREQ = 50000000; // 50 MHz clock frequency

    localparam BIT_PERIOD = CLK_FREQ / BAUD_RATE;
    localparam IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;

    reg [1:0] state;
    reg [3:0] bit_index;
    reg [15:0] bit_counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            bit_index <= 4'b0;
            bit_counter <= 16'b0;
            busy <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    busy <= 1'b0;
                    if (send) begin
                        state <= START;
                        busy <= 1'b1;
                    end
                end
                START: begin
                    tx <= 1'b0; // Start bit
                    if (bit_counter == BIT_PERIOD - 1) begin
                        bit_counter <= 0;
                        state <= DATA;
                    end else
                        bit_counter <= bit_counter + 1;
                end
                DATA: begin
                    tx <= data_in[bit_index];
                    if (bit_counter == BIT_PERIOD - 1) begin
                        bit_counter <= 0;
                        if (bit_index == 7)
                            state <= STOP;
                        else
                            bit_index <= bit_index + 1;
                    end else
                        bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    tx <= 1'b1; // Stop bit
                    if (bit_counter == BIT_PERIOD - 1) begin
                        state <= IDLE;
                    end else
                        bit_counter <= bit_counter + 1;
                end
            endcase
        end
    end
endmodule
</code></pre>
</article>
	
						<!-- Post -->
						 
						
							<article class="post">
								<header>
									<div class="title">
										<h2><a href="#">Sensor Fusion:Heat Tracking and Suppression </a></h2>
										<p>Tiva MCU Board I2C, SPI, UART  Sensor Integration in C <Cap></Cap></p>
									</div>
									<div class="meta">
										
										</div>
								</header>
								

								<section>
									<a href="single.html" class="image featured"><img src="tiva.jpg" alt="" /></a>
									<h3>Objective:</h3>
									<p style="font-size: 1.5em; font-weight: normal;">
										The Heat-Triggered Fan project aims to enhance environmental comfort and energy efficiency through automated, responsive cooling based on ambient temperature readings.
								
									<h3>Description:</h3>
									<p style="font-size: 1.5em; font-weight: normal;">

									This advanced system leverages sensor fusion technology to accurately monitor environmental conditions. Utilizing a combination of sensors communicating over I2C and UART interfaces, the system ensures precise temperature detection. When the ambient temperature exceeds a set threshold, the system activates a fan, efficiently mitigating heat without human intervention.
									
									<h3>Sensor Fusion:</h3>
									<p style="font-size: 1.5em; font-weight: normal;">
									Employs multiple sensors via I2C and UART protocols for accurate temperature readings and reliable system performance.
									Automatic Activation: The fan is triggered automatically at a specific temperature threshold, maintaining consistent climate control.
									Energy Efficient: Operates the fan only when necessary, significantly reducing energy use.
									User-Friendly Interface: Allows users to easily adjust temperature thresholds and fan speeds according to their preferences.
									Functionality: At the core of the system is a microcontroller unit (MCU) that orchestrates all operations. It processes inputs from digital thermostats connected through I2C and additional sensors interfaced via UART. This dual communication strategy enhances the reliability and accuracy of the temperature readings, forming a solid basis for the activation logic of the fan.
									
									<h3>Features</h3>
									<p style="font-size: 1.5em; font-weight: normal;">
                                    Enhanced Comfort: Automatically keeps indoor environments at a comfortable temperature.
									Cost-Effective: Lowers energy bills by optimizing when and how the fan is used.
									Environmentally Friendly: Improves energy efficiency, contributing to a lower carbon footprint.
									Technical Innovation: Integrates sophisticated sensor and communication technologies to provide a cutting-edge solution to climate control.
									Applications: This system is particularly suited for residential homes, offices, and industrial settings where maintaining a set temperature efficiently is crucial.
									<h3>Conclusion:</h3>
									<p style="font-size: 1.5em; font-weight: normal;">
									 The Heat-Triggered Fan project represents a significant advancement in smart climate control technologies. By integrating precise sensor fusion with sophisticated MCU management over I2C and UART interfaces, it delivers a highly effective, energy-efficient cooling solution that enhances both comfort and environmental sustainability.</p>
									
									<hr />
									
									<h3>Code</h3>
									<h4>main.c</h4>
									<pre><code>
										//Oscar Barajas
										//Sensor Fusion Project
										//Tiva Board Integration with Thermal Sensor I2C
										#include "TM4C123GH6PM.h"
										#include "stint.h"
										#include "string.h"
									
										
										
										
										
										void Delay_MicroSecond(int time); // generates delay in microseconds
										void Servo_write(int pin, int angle);
										void Servo_Init( void );
										static int I2C1_wait_till_done(void);
										void I2C1_Init ( void ); 
										int I2C1_Write_Multiple(int slave_address, char slave_memory_address, int bytes_count, uint8_t * data);
										int I2C1_read_Multiple(uint8_t slave_address, char slave_memory_address, int bytes_count, uint8_t * data);
										long map(long x, long in_min, long in_max, long out_min, long out_max) ;
										void Delay_MicroSecond(int time);
										/*UART function prototypes*/
										void UART0_Init( void );
										char UART0_Receive( void );
										void UART0_Transmit(unsigned char data);
										void printstring(char *str);
										
										/*Delay Function*/
										uint32_t ms;
										
										/*Switch Init*/
										void Switches_Init();
										
										void _delay_ms(uint16_t delay){
											ms = 0;
											while(delay > ms);
										}
										
										/*MLX90614 Functions and Variable declarations*/
										#define MLX90614_I2CADDR 0x5A
										
										// RAM
										#define MLX90614_RAWIR1 0x04
										#define MLX90614_RAWIR2 0x05
										#define MLX90614_TA 0x06
										#define MLX90614_TOBJ1 0x07
										#define MLX90614_TOBJ2 0x08
										
										double readObjectTempC( void );
										double readTemp(uint8_t reg);
										uint16_t read16(uint8_t reg);
										static double tempC, tempF;
										static char c[50];
										
										#define IN_A	2
										#define IN_B	3
										#define THRESH 30 //you can change temperature threshold here
										#define SERVO1 3
										#define SERVO2 4
										
										
										int fanState = 0;
										void forward(){
											GPIOF->DATA |= (1 << IN_A) | (0 << IN_B);
											fanState = 1;
										}
										
										void reverse(){
											GPIOF->DATA |= (0 << IN_A) | (1 << IN_B);
											fanState = 2;
										}
										
										void stopFan(){
											GPIOF->DATA |= (0 << IN_A) | (0 << IN_B);
											fanState = 0;
										}
										
										void Fan_Motor_Init(){
											SYSCTL->RCGCGPIO |= 0x20;
											GPIOF->LOCK = 0x4C4F434B;   // unlockGPIOCR register
											GPIOF->CR = 0x01;
											GPIOF->DIR |= ((1<DEN |= ((1< THRESH){
													if(fanState != 1){
														printstring("Temp > THRESH");
														forward();
													}
												}else{
													if(fanState > 0){
														printstring("Stop Fan");
														stopFan();
													}
												}
										}
										
										int main(void)
										{
											UART0_Init();
											Fan_Motor_Init();
											I2C1_Init(); 
											Servo_Init();
											Servo_write(3, 180);
											Servo_write(4, 0);
											Delay_MicroSecond(2000000);
											  while(1)
											{
													
												  int pa3_angle = 0;
												  int clockwise = 0;
													for (pa3_angle = 180; pa3_angle >=  0; pa3_angle -= 10){
														int pa4_angle = 0;
														Servo_write(3, pa3_angle); //10 degrees y-axis
														Delay_MicroSecond(100000);
														
														//if(clockwise == 1){
															//for (pa4_angle = 0; pa4_angle <=  180; pa4_angle += 10){
																readTemp_FanOn();
																Servo_write(4, 180);
																Delay_MicroSecond(100000);
															//}
														//}else{
															//for (pa4_angle = 180; pa4_angle >=  0; pa4_angle -= 10){
																readTemp_FanOn();
																Servo_write(4, 0);
																Delay_MicroSecond(100000);
															//}
														//}
														
														//clockwise = !clockwise;
														
														
														//Delay_MicroSecond(100000);
														
													}
													Delay_MicroSecond(1000000);
													Servo_write(3, 180);
													Delay_MicroSecond(1000000);
													/*
													for (pa3_angle = 180; pa3_angle >=  0; pa3_angle -= 10){
														int pa4_angle = 0;
														Servo_write(3, pa3_angle);
														Delay_MicroSecond(100000);
														for (pa4_angle = 0; pa4_angle <=  180; pa4_angle += 10){
															Servo_write(4, pa4_angle);
															Delay_MicroSecond(100000);
														}
														//Delay_MicroSecond(100000);
														for (pa4_angle = 180; pa4_angle >=  0; pa4_angle -= 10){
															Servo_write(4, pa4_angle);
															Delay_MicroSecond(100000);
														}
													}
													Delay_MicroSecond(1000000);
													
													*/
											   
											}
											
										}
										
										
										long map(long x, long in_min, long in_max, long out_min, long out_max) {
										  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
										}
										
										void Servo_write( int servo_pin, int angle ){
											
											int i=0;
										 
											int d1 = map(angle, 0, 180, 1000, 2000);
											int d2 = 20000 - d1;
											
											if ( d2 == 0) { d2 = 1000;}
											
											for(i=0; i<50; i++) 
											{
											  /* Given 10us trigger pulse */
											  GPIOA->DATA |= (1 << servo_pin); /* make control  pin high */
											  Delay_MicroSecond(d1); 
											  GPIOA->DATA &= ~(1 << servo_pin); /* make control  pin low */
											  Delay_MicroSecond(d2); 
										  }
										}
										
										void Servo_Init( void ) {
											/* PA4 as a digital output signal to provide trigger signal */
											SYSCTL->RCGCGPIO |= 1;      /* enable clock to PORTA */
											GPIOA->DIR |=(1<<4) | (1 << 3);         /* set PA4, PA3 as a digial output pin */
											GPIOA->DEN |=(1<<4) | (1 << 3);         /* make PA4,PA3 as digital pin */
										}
										
										
										void Switches_Init(){
											SYSCTL->RCGCGPIO |= (1<<5); 
											
										}
										
										void UART0_Init( void ){
											SYSCTL->RCGCUART |= 1; /* enable clock for UART0 */
											SYSCTL->RCGCGPIO  |= 0x01 ; /* enable clock for UART0 */
											
											/*Systick Timer Initialization*/
											SysTick->CTRL = 0x03;
											SysTick->LOAD = 4000 - 1; 
											
											GPIOA->DEN = 0x03;      /* set PA0 and PA1 as digital */
										  GPIOA->AFSEL = 0x03;    /* Use PA0,PA1 alternate function */
										  GPIOA->AMSEL = 0;       /* Turn off analg function*/
										  GPIOA->PCTL = 0x00000011;     /* configure PA0 and PA1 for UART */
											
											/* UART0 initialization */
											UART0->CTL = 0;         /* UART5 module disbable */
											UART0->IBRD = 104;      /* for 9600 baud rate, integer = 104 */
											UART0->FBRD = 11;       /* for 9600 baud rate, fractional = 11*/
											UART0->LCRH = 0x60;     /* data lenght 8-bit, not parity bit, no FIFO */
											UART0->CC = 0;          /* select system clock*/
											UART0->CTL = 0x301;     /* Enable UART5 module, Rx and Tx */
											
											
										}
										
										char UART0_Receive(void)  
										{
											char data;
											  while((UART0->FR & (1<<4)) != 0){} /* wait until Rx buffer is not full */
											data = UART0->DR ;  	/* before giving it another byte */
											return (unsigned char) data; 
										}
										
										void UART0_Transmit(unsigned char data)  
										{
											while((UART0->FR & (1<<5)) != 0); /* wait until Tx buffer not full */
											UART0->DR = data;                  /* before giving it another byte */
										}
										
										void printstring(char *str)
										{
										  while(*str)
											{
												UART0_Transmit(*(str++));
											}
										}
										
										void I2C1_Init( void ){
											SYSCTL->RCGCGPIO  |= 0x01 ; // Enable the clock for port A
											SYSCTL->RCGCI2C   |= 0x02 ; // Enable the clock for I2C 1
											GPIOA->DEN |= ( 1 << 6 | 1 << 7); // Assert DEN for port A
											// Configure Port A pins 6 and 7 as I2C1
											GPIOA->AFSEL |= 0xc0 ;
											GPIOA->PCTL |= 0x33000000 ;
											GPIOA->ODR |= (1<<7) ; // SDA (PA7 ) pin as open darin
											GPIOA->AMSEL &= ~( 1 << 6 | 1 << 7);
											I2C1->MCR  = 0x0010 ; // Enable I2C 3 master function
											/* Configure I2C 3 clock frequency
											(1 + TIME_PERIOD ) = SYS_CLK /(2*
											( SCL_LP + SCL_HP ) * I2C_CLK_Freq )
											TIME_PERIOD = 16 ,000 ,000/(2(6+4) *100000) - 1 = 7 */
											I2C1->MTPR  = 0x07 ;
										}
										
										/* wait untill I2C Master module is busy */
										/*  and if not busy and no error return 0 */
										static int I2C1_wait_till_done(void)
										{
											while(I2C1->MCS & 1);   /* wait until I2C master is not busy */
											return I2C1->MCS & 0xE; /* return I2C error code, 0 if no error*/
										}
										
										int I2C1_Write_Multiple(int slave_address, char slave_memory_address, int bytes_count, uint8_t * data)
										{   
											int error;
											if (bytes_count <= 0)
												return -1;                  /* no write was performed */
											/* send slave address and starting address */
											I2C1->MSA = slave_address << 1;
											I2C1->MDR = slave_memory_address;
											I2C1->MCS = 3;                  /* S-(saddr+w)-ACK-maddr-ACK */
										
											error = I2C1_wait_till_done();   /* wait until write is complete */
											if (error) return error;
										
											/* send data one byte at a time */
											while (bytes_count > 1)
											{
												I2C1->MDR = *data++;             /* write the next byte */
												I2C1->MCS = 1;                   /* -data-ACK- */
												error = I2C1_wait_till_done();
												if (error) return error;
												bytes_count--;
											}
											
											/* send last byte and a STOP */
											I2C1->MDR = *data++;                 /* write the last byte */
											I2C1->MCS = 5;                       /* -data-ACK-P */
											error = I2C1_wait_till_done();
											while(I2C1->MCS & 0x40);             /* wait until bus is not busy */
											if (error) return error;
											return 0;       /* no error */
										}
										
										
										int I2C1_read_Multiple(uint8_t slave_address, char slave_memory_address, int bytes_count, uint8_t * data)
										{
											int error;
											
											if (bytes_count <= 0)
												return -1;         /* no read was performed */
										
											/* send slave address and starting address */
											I2C1->MSA = slave_address << 1;
											I2C1->MDR = slave_memory_address;
											I2C1->MCS = 3;       /* S-(saddr+w)-ACK-maddr-ACK */
											error = I2C1_wait_till_done();
											if (error)
												return error;
										
											/* to change bus from write to read, send restart with slave addr */
											I2C1->MSA = (slave_address << 1) + 1;   /* restart: -R-(saddr+r)-ACK */
										
											if (bytes_count == 1)             /* if last byte, don't ack */
												I2C1->MCS = 7;              /* -data-NACK-P */
											else                            /* else ack */
												I2C1->MCS = 0xB;            /* -data-ACK- */
											error = I2C1_wait_till_done();
											if (error) return error;
										
											*data++ = I2C1->MDR;            /* store the data received */
										
											if (--bytes_count == 0)           /* if single byte read, done */
											{
												while(I2C1->MCS & 0x40);    /* wait until bus is not busy */
												return 0;       /* no error */
											}
										 
											/* read the rest of the bytes */
											while (bytes_count > 1)
											{
												I2C1->MCS = 9;              /* -data-ACK- */
												error = I2C1_wait_till_done();
												if (error) return error;
												bytes_count--;
												*data++ = I2C1->MDR;        /* store data received */
											}
										
											I2C1->MCS = 5;                  /* -data-NACK-P */
											error = I2C1_wait_till_done();
											*data = I2C1->MDR;              /* store data received */
											while(I2C1->MCS & 0x40);        /* wait until bus is not busy */
											
											return 0;       /* no error */
										}
										
										double readObjectTempC( void ){
											return readTemp(MLX90614_TOBJ1);
										}
										
										double readTemp(uint8_t reg){
											double temp;
										  temp = read16(reg);
										  if (temp <= 0){
												return 0;
											}
											
										  temp *= 0.02;
										  temp -= 273.15;
										  return temp;
										}
										
										uint16_t read16(uint8_t reg){
											uint8_t buffer[2];
											I2C1_read_Multiple(MLX90614_I2CADDR, reg, 2, buffer);
											return (uint16_t)((buffer[0]) | (buffer[1] << 8));
										}
										
										void SysTick_Handler(){
											ms++;
										}
										
										
										/* Create one microsecond second delay using Timer block 1 and sub timer A */
										
										void Delay_MicroSecond(int time)
										{
											int i;
											SYSCTL->RCGCTIMER |= 2;     /* enable clock to Timer Block 1 */
											TIMER1->CTL = 0;            /* disable Timer before initialization */
											TIMER1->CFG = 0x04;         /* 16-bit option */ 
											TIMER1->TAMR = 0x02;        /* periodic mode and down-counter */
											TIMER1->TAILR = 16 - 1;  /* TimerA interval load value reg */
											TIMER1->ICR = 0x1;          /* clear the TimerA timeout flag */
											TIMER1->CTL |= 0x01;        /* enable Timer A after initialization */
										
											for(i = 0; i < time; i++)
											{
												while ((TIMER1->RIS & 0x1) == 0) ;      /* wait for TimerA timeout flag */
												TIMER1->ICR = 0x1;      /* clear the TimerA timeout flag */
											}
										</code></pre>
							

								

								<section>
									
									<h3>Flowchart</h3>
									
									<div class="box alt">
										<div class="row gtr-uniform">
											<div class="col-12"><span class="image fit"><img src="flowchart.jpg" alt="" /></span></div>
											<div class="col-4"><span class="image fit"><img src="tiva1.jpg" alt="" /></span></div>
											<div class="col-4"><span class="image fit"><img src="tiva2.jpg" alt="" /></span></div>
											<div class="col-4"><span class="image fit"><img src="tiva3.jpg" alt="" /></span></div>
										
										</div>
									</div>
									</section>

							</article>
						

						<!-- Post -->
						<article class="post">
							<header>
								<div class="title">
									<h2><a >Embedded Systems:Enviromental Control System </a></h2>
									<p>Enclosed Mushroom Eviroment Control System IOT Project</p>
								</div>
								
								
							</header>

							<section>
								<a href="single.html" class="image featured"><img src="mushroom1.jpg" alt="" /></a>
								<h3>Project Overview:</h3>
								<p style="font-size: 1.5em; font-weight: normal;">

									Our aim is to craft a system that not only talks to mushrooms in their language - humidity, temperature, and CO2 - but also listens to them, adjusting their environment to help them thrive. This isn’t just a control system; it's a cultivation companion for gourmet mushroom aficionados on a budget.As inflation rises, so do food prices and the amount of hours worked required to acquire your food. Furthermore, there is less and less space for the production of food in major cities where food demand and waste is highest. With the way that our economy is going it would not be unreasonable to think that we will soon find ourselves in another recession and unable to purchase luxury items like gourmet mushrooms. 
							<p>
								<h3>Design & Testing:</h3> 
								

<h2>Hygroscopic Harp (Humidity Sensor):</h2> Sensing percents of water particles vapor in the enclosed system
<h2>Thermal Flute (Temperature Sensor):</h2>Measuring thetemperature  ensuring the ambient embrace is just right.
<h2>Carbon and O2 (CO2 & O2 Sensor):</h2> Detecting amount C02 and O2 present in the system
<h2>Relay Control</h2> Provide control to change enviromental parameters such as trigger hummidifiser to increase humiduty or open vent to increase O2.
<h2>User Interface LCD Screen</h2> A window allowing user to see and cycle through measured parameters
							</p>
								
								
								<hr />
								
								<h4>main.c</h4>
								<pre><code>
							
									#include "inc/hw_memmap.h"
									#include "inc/hw_types.h"
									#include "driverlib/sysctl.h"
									#include "driverlib/gpio.h"
									
									// Define ports and pins for sensors and relays
								
									#define HUMIDITY_SENSOR_PORT GPIO_PORTA_BASE
									#define TEMPERATURE_SENSOR_PORT GPIO_PORTB_BASE
									#define CO2_SENSOR_PORT GPIO_PORTC_BASE
									#define RELAY_PORT GPIO_PORTD_BASE
									#define HUMIDITY_SENSOR_PIN GPIO_PIN_2
									#define TEMPERATURE_SENSOR_PIN GPIO_PIN_3
									#define CO2_SENSOR_PIN GPIO_PIN_4
									#define RELAY_PINS (GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4)
									
									// Initialize the system peripherals
									void setupPeripherals(void) {
										// Clock setup: running from the crystal for accuracy
										SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);
									
										// Enable GPIO ports for sensors and relays
										SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
										SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
										SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
										SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
									
										// Sensor pins as input for monitoring, relay pins as output to control environment
										GPIOPinTypeGPIOInput(HUMIDITY_SENSOR_PORT, HUMIDITY_SENSOR_PIN);
										GPIOPinTypeGPIOInput(TEMPERATURE_SENSOR_PORT, TEMPERATURE_SENSOR_PIN);
										GPIOPinTypeGPIOInput(CO2_SENSOR_PORT, CO2_SENSOR_PIN);
										GPIOPinTypeGPIOOutput(RELAY_PORT, RELAY_PINS);
									}
									
									// Monitor sensors and react to keep the mushrooms happy
									void readSensorsAndControlEnvironment(void) {
										// Storing sensor readings
										uint32_t humidity_level, temp_level, co2_level;
									
										// Grab the current conditions from our sensors
										humidity_level = GPIOPinRead(HUMIDITY_SENSOR_PORT, HUMIDITY_SENSOR_PIN);
										temp_level = GPIOPinRead(TEMPERATURE_SENSOR_PORT, TEMPERATURE_SENSOR_PIN);
										co2_level = GPIOPinRead(CO2_SENSOR_PORT, CO2_SENSOR_PIN);
									
										
										if (humidity_level < IDEAL_HUMIDITY) {
											GPIOPinWrite(RELAY_PORT, RELAY_PINS, GPIO_PIN_1); // Engage the humidity!
										} else {
											GPIOPinWrite(RELAY_PORT, RELAY_PINS, 0); // Stand down, humidifier
										}
									
										// Apply similar logic for temperature and CO2 here
									}
									
									
									int main(void) {
										setupPeripherals(); // Gotta set up our gear first
									
										// Main loop: like the heartbeat of our system, checking and adjusting
										while (1) {
											readSensorsAndControlEnvironment(); // Constant vigilance!
											// Wait a bit before doing it all over again
											SysCtlDelay(SysCtlClockGet() / 6); 
										}
									}</code></pre>
						

							

							<section>
								<h3>Imagee</h3>
								<h4>Fit</h4>
								<div class="box alt">
									<div class="row gtr-uniform">
										<div class="col-6"><span class="image fit"><img src="mushroom2.jpg" alt="" /></span></div>
										<div class="col-6"><span class="image fit"><img src="mushroom3.jpg" alt="" /></span></div>
										<div class="col-6"><span class="image fit"><img src="mushroom4.jpg" alt="" /></span></div>
										<div class="col-6"><span class="image fit"><img src="mushroom5.jpg" alt="" /></span></div>
										<div class="col-9"><span class="image fit"><img src="mushroom6.jpg" alt="" /></span></div>
									
								 		</div>
								</div>
							</section>

						</article>

						<!-- Pagination -->
						
					

					</div>

				<!-- Sidebar -->
					<section id="sidebar">

						<!-- Intro -->
							<section id="intro">
								<a href="#" class="logo"><img src="logo.jpg" alt="" /></a>
								<header>
									<h2>Oscar Barajas</h2>
								
								</header>
							</section>

							<section class="blurb">
								<h2>About Me</h2>
								<p class="about-text">
									I am <strong>Oscar Barajas</strong>, a <strong>Field Engineer at Siemens Mobility</strong>, with a strong background in 
									<span class="highlight">hardware design, electrical design, real-time systems, and firmware development</span>. 
									My expertise lies in designing and optimizing embedded solutions, integrating 
									<span class="highlight">microcontrollers, FPGAs, and sensors</span> for real-world applications.
								</p>
								<p class="about-text">
									I am currently pursuing my <strong>Master of Science in Electrical and Computer Engineering</strong> 
									at <strong>San Francisco State University</strong>, where I have worked on 
									<span class="highlight">VLSI design, hardware validation, electrical circuit design, and embedded software development</span>.
								</p>
								<p class="about-text">
									As a <strong>Field Engineer at Siemens Mobility</strong>, I specialize in 
									<span class="highlight">hardware troubleshooting, system validation,software regressiong testing, static testing and fault diagnosis</span> 
									for railway control systems, ensuring high reliability and efficiency in critical transportation infrastructure. 
									My hands-on experience includes:
								</p>
								<ul class="actions">
							
									
								</ul>
							</section> 
						<!-- Mini Posts -->
							<section>
								<div class="mini-posts">

					
										<!-- Mini Post -->
									<article class="mini-post">
										<header>
											<h3 class="full-width">Bachelor of Science in Electrical Engineering</h3>
											<h4>San Francisco State University</h4>
											<p>Spring 2017 - Fall 2021</p>
										</header>
										<div class="image"><img src="sfsulogo.jpg" alt="SFSU Logo" /></div>
									</article>

									<!-- Mini Post -->

									<!-- Mini Post -->
									<article class="mini-post">
										<header>
											<h3 class="full-width">Master of Science in Electrical and Computer Engineering</h3>
											<h4>San Francisco State University</h4>
											<p>Spring 2023 - Fall 2025</p>
										</header>
										<div class="image"><img src="sfsulogo.jpg" alt="SFSU Logo" /></div>
									</article>

									
							</section>

					</section>

			</div>

		<!-- Scripts -->
			<script src="jquery.min.js"></script>
			<script src="browser.min.js"></script>
			<script src="breakpoints.min.js"></script>
			<script src="util.js"></script>
			<script src="main.js"></script>

	</body>
</html>